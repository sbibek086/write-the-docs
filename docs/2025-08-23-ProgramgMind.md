---
layout: default
title: üë®‚Äçüíªüß†
category: Programming
tags: [Programming]

---

![bott](https://github.com/user-attachments/assets/ee62be61-e4dc-4b29-badd-9a311816e35c)

_Enof wisdom is in this book not only for programmg but as whole life, so need to watch new Life Wisdom I guess- no OshoStuffs n etc -isms. Vivek, I got work to do- c o d e n NOT keep returning to back-to-square-1-Oh-How-to-code. etc_

exerpt from Pragmatic Programmer pdf:

euta kachra fala in 1 place. people will keep throwing there more, thinking Oh its shit place. Keep it clean - none will bother to trash-ify more. thats entropy.

--

Every now and then, you might want to emulate stone soup story. 

You may be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes ‚Äîyou know it‚Äôs right. But ask permission to tackle the whole thing and you‚Äôll be met with delays and blank stares. People will form committees, budgets will need approval, and things will get complicated. Everyone will guard their own resources. Sometimes this is called ‚Äústart-up fatigue.‚Äù

Then, It‚Äôs time to bring out the stones trick. 

Work out what you can reasonably ask for. Develop it well. Once you‚Äôve got it, show people, and let them marvel. Then say ‚Äúof course, it wud be better if we added .‚Äù Pretend it‚Äôs not important. Sit back and wait for them to start asking you to add the functionality you originally wanted. People Ô¨Ånd it easier to join
an ongoing success. Show them a glimpse of the future and you‚Äôll get them to rally around.

--

In Kachraa problem, people lose will to Ô¨Åght entropy because they perceive that no one else cares. 

While frog-Which-Sits-On-SLOWLY-hitting-water just doesn‚Äôt notice the change.

Don‚Äôt be like the frog. Keep an eye on the big picture. Constantly review what‚Äôs happening around you, not just what you personally are doing.

--

GOOD ENOUGH SOFTWARE: u can discipline yourself to write software that‚Äôs good enough‚Äîgood enough for your users, for future maintainers, for your own peace of mind. You‚Äôll Ô¨Ånd that you are more productive and your users are happier. And you may well Ô¨Ånd that your programs are actually better for their shorter incubation.

Before we go any further, we need to qualify what we‚Äôre about to say.
The phrase ‚Äúgood enough‚Äù does not imply sloppy or poorly produced code. All systems must meet their users‚Äô requirements to be successful. We are simply advocating that users be given an opportunity to participate in the process of deciding when what you‚Äôve produced is good enough.
Involve Your Users in the Trade-Off
Normally you‚Äôre writing software for other people. Often you‚Äôll remember to get requirements from them. 
But how often do you ask them how good they want their software to be? 

If you‚Äôre working on new app, you‚Äôll have different constraints. Marketing people will have promises to keep, the eventual end users may have made plans based on a delivery schedule, and your company will certainly have cash-Ô¨Çow constraints. It would be unprofessional to ignore these users‚Äô requirements simply to add new features to the program, or to polish up the code just one more time. We‚Äôre not advocating panic: it is equally unprofessional to promise impossible time scales n to cut basic engineering corners to meet a deadline.

The scope and quality of the system you produce should be speciÔ¨Åed as part of that system‚Äôs requirements. Often you‚Äôll be in situations where trade-offs are involved. 

Surprisingly, many users would rather use software with some rough edges today than wait a year for the multimedia version. _So, app initial inner circle lai prayog garna dee haal._

BUT  KNOW WHEN TO STOP:
In some ways, programming is like painting. painting improvise garna kehi thapera stepBack n look BigPic ta garnu parchh BUT tooMuchPerfection ko naam ma 'throw a canvas away and start again' jasto gari rahana hunna. All the hard work is ruined if you don‚Äôt know when to stop. If you add layer upon layer, detail over detail, the
painting becomes lost in the paint. 

Don‚Äôt spoil a perfectly good program by overembellishment and over-reÔ¨Ånement. Move on, and let your code stand in its own right for a while. It may not be perfect. Don‚Äôt worry: it could never be perfect. 

--

Invest in KNOWLEDGE just like invest in stocks by:
1. Serious investors invest regularly‚Äîas a habit.
2. DiversiÔ¨Åcation is the key to long-term success- As a baseline, you need to know the ins and outs of particular technology you are working with currently. But don‚Äôt
stop there. The face of computing changes rapidly‚Äîhot technology today may well be close to useless (or at least not in demand) tomorrow. The more technologies you are comfortable with, the better u will be able to adjust to change.
3. Smart investors balance their portfolios between conservative (je legacy wala which gives u breadButter) and high-risk, high-reward investments.
4. try to catch up new tech like finding about btc in 2012. 
5. Portfolios should be reviewed and rebalanced periodically.

TakeClasses, ParticipateInLocalUserGroups, StayCURRENT, AskGURUs 

_Just because a Web search engine lists a hit Ô¨Årst doesn‚Äôt mean that it‚Äôs the best match; content provider can pay to get top billing. Just because a bookstore
features a book prominently doesn‚Äôt mean it‚Äôs a good book, or even popular; they may have been paid to place it there._

--

As programmer, you are 

-part listener

-part advisor

-part interpreter

-part dictator.

You try to capture elusive (difficult to find, catch, achieve) requirements

& find a way of expressing them so that mere machine can do justice. U have to be able to make machine do so.

-You try to document your work so that others can understand it.

-You try to engineer your work so that others can build on it, that too against ticking of time, you work small miracles everyday.

--
Not necessary that 1 by-the-book thing as best solution in ur situation. Situation dictates it. You adjust your approach to suit current circumstances. You judge relative importance of all factors affecting project n use ur experience to produce appropriate soln.

You should have broad enough background n experience base to allow u to choose good soln in case that u are now facing.

Your background stems from understanding of basic principles of computer science N your experience comes from wider range of practical subjects. THEORY n PRACTICE combine u to make strong.

--
Each developer is unique, w individual strengths n weaknessses, preference n dislikes. 

Over time, each will craft his/her own personal environment. That environment will reflect his/ her individuality of solving problems, tools/ approach he uses, just as forcefully as his/her hobbies.

So, way/approach of solving problem is not one - by-the-book kind. However, pragmatism can be best summarized as below traits:

-Early adopter/ fast adopter: U have instinct for tech n techniques, n you love trying things out. When given sthg new, u can grasp it quickly n integrate it w rest of your knowledge.

-Inquisitive (having/ showing interest in learning things after being convinced, ok there's pt. learningn it): U tend to ask questions- 'How did u do that' 'Did you have problems w that library' 'What;s this llm that I've been hearing about' 'How are symbolic links implemented' etc

-Critical Thinker: U rarely take things for granted without getting the facts. I have talked about this Not-Impulsive-But-paying-attention-to-details in 'Cavemen's dilemma' blogpost

-Realistic n resilient: U try to understand udnerlying nature of each problem. This realism orientation gives u good feel of how difficult things are, n how long things will take. Understanding for urself that a process would be difficult gives u stamina to keep at it.

-Jack of all trades, master at one

--

Care ur craft, think about ur work

--

In order to be pragmatic programmer, u will feel challenged to think about what u're doing while doing it. This isnt one time audit of current practices - it'ss ongoing critical appraisal of every decision u make, everyday n in every development. 

Never run on auto-pilot Constantly be thinking, critiquing your work in real time.

--
Individual pragmatists, each one in even large teams. One who cuts mere stones must always be envisioning cathedrals.

--
Improvement is a continuous ongoing process.

--
Producing formatted documents from the comments and declarations in source code is fairly straightforward, but Ô¨Årst we have to ensure that
we actually have comments in the code. 

In code, comments should discuss O N L Y why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant and is a violation of the DRY principle. 

Commenting source code gives you the perfect opportunity to document those elusive bits of a project that can‚Äôt be documented anywhere else: engineering trade-offs, why decisions were made, what other alternatives were discarded, and so on.

We like to see a simple module-level header comment, comments for signiÔ¨Åcant data and type declarations, and a brief per-class and per-method header, describing how the function is used and anything that it does that is not obvious.

Variable names, of course, should be well chosen and meaningful. foo, for instance, is meaningless, as is doit or manager or stuff. Even Worse is Misleading names, DONT.

<img width="343" height="405" alt="image" src="https://github.com/user-attachments/assets/3b7b64d3-e352-4d96-b5b3-32201ecb0928" />





                 
